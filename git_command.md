##### git please

```
git config --global alias.please 'push --force-with-lease'
```

Каждому разработчику приходилось хотя бы раз общаться со своим тимлидом на тему принудительного пуша (force pushing) в общую ветку (не делайте этого).
Git-опция --force-with-lease действует гораздо аккуратнее: она проверяет, чтобы ваша локальная копия ref’а была самой свежей, 
прежде чем накатить её. Это означает, что вы как минимум подтянули все изменения, которые собираетесь затоптать. 
Но чтобы не писать каждый раз git push --force-with-lease, я сделал для этой строки алиас: git please

##### git commend
```
git config --global alias.commend 'commit --amend --no-edit'
```
Бывало так, что вы закоммитили и тут же сообразили, что забыли проиндексировать (stage) файл? Больше не нужно об этом беспокоиться! Алиас git commend тихо прикрепляет к последнему созданному вами коммиту все проиндексированные файлы, 
повторно используя уже имеющееся сообщение о коммите. 

##### git it
```
git config --global alias.it \
'!git init && git commit -m “root” --allow-empty'
```
Первому коммиту в репозитории нельзя сделать ребейз, как обычному. Поэтому рекомендуется в качестве корневого создавать пустой коммит. Алиас git it инициализирует ваш репозиторий и за одну операцию создаёт пустой корневой коммит. И когда вы в следующий раз запустите проект, 
то не надо просто добавлять его в систему управления версиями: выполните git it!

##### git stash
```
git config --global alias.stsh 'stash --keep-index'
git config --global alias.staash 'stash --include-untracked'
git config --global alias.staaash 'stash --all'
```
git stash — одна из самых восхитительных и полезных Git-команд. Она регистрирует все изменения, вносимые в отслеживаемый файл в вашем рабочем дереве, 
и скрывает их для последующего использования, а вам показывает чистое дерево, чтобы вы могли спокойно работать с другой его частью. Но если вы создали новые файлы и ещё не проиндексировали их, то по умолчанию git stash их не тронет, поэтому у вас будет неопрятное рабочее дерево. 
Соответственно, по умолчанию не скрывается и содержимое неотслеживаемых или игнорируемых файлов.

##### git shorty
```
git config --global alias.shorty 'status --short --branch'
```
Например, git status объясняет мне в 12 строках, что у меня пара индексированных, неиндексированных и неотслеживаемых изменений.
Всё то же самое git shorty говорит мне тремя строками

##### git grog
```
git config --global alias.grog 'log --graph --abbrev-commit --decorate --all --format=format:"%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(dim white) - %an%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n %C(white)%s%C(reset)"'
```
git grog (или graphical log) в последние годы разросся настолько, что я больше не уверен, будто точно знаю, что он делает. Но выглядит красиво.

