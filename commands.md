### Команды для работы
##### vim
- :%s/^https.*// - удалить все строки начинающиеся с https, но оставляет их пустыми
- :g/^https.*/d - удаляет все строки начинающиеся с https и их сами
- :%s/https:\/*//g - заменяет вхождения 'https://'' на пустую строку''

#### bash небольшие рецепты
- Вывод всех открытых портов на сервере
```
netstat -tupln
```
- Создание каталога и подкаталогов для него
```
# mkdir -p /tmp/subdir1/subdir2/subdir3
```
- Исправление неверных путей
```
shopt -s cdspell
```
- Прибавить или отнять время от текущего
```
date --date="1 hour( ago)"
```
- Вернуться к скрытому процессу по его номеру(номер процесса можно узнать с помощью команды `jobs`)
```
fg %1
```
- Найти все файлы размером более 100Мб
```
find / -type f -size +100M
```
- Найти файлы, которые не были изменены за последние 60 дней(а которые были изменены поменять '+' на '-')
```
find . -mtime +60
```
- Погасить весь вывод от команды
```
cat file.txt > /dev/null
```
- Погасить только stderr(2)
```
cat invalid-file-name.txt 2> /dev/null
```
- Заменить все символы в верхний регистр
```
tr a-z A-Z < file.txt
```
- Выполнить загрузку файлов с нескольких URL
```
cat url-list.txt | xargs wget –c
```
- Вывести общее количество оперативной памяти
```
free | tr -s ' ' | sed '/^Память/!d' | cut -d" " -f2
```
- Открыть дисковод
```
eject
```
- Удаление cookie файлов в Ubuntu
```
COOKIES="~/.mozilla/firefox/*.default/cookies.sqlite"
if [ -f "$COOKIES" ]; then
    rm -f "$COOKIES"
fi
ln -s /dev/null "$COOKIES"
```
- Получить ключи переданные команде
```
echo $_
```
- Повтороние последней команды
```
Используйте стрелку вверх, чтобы просмотреть предыдущую команду и нажмите клавишу Enter, чтобы выполнить её.
Введите !! и нажмите клавишу Enter.
!-1 и нажмите клавишу Enter.
Нажмите Control+P
```
- Генерация псевдослучайного числа
```
echo $RANDOM 
```
- Выполинить команду из истории
```
history | more
```
Затем ввести номер команды
```
!4
```
- Заменить последнюю команду на новую
```
cat file.txt
vim !!:$
```
Или
```
vim !^
```
- Отключить историю BASH
```
export HISTSIZE=0
```
- Наложение заплат на модули ядра
```
patch -p1 <patch-file
# Применит все изменения из 'patch-file'
# к файлам, описанным там же.
# Так выполняется обновление пакетов до более высоких версий.
```
- Количетсво ядре процессора
```
grep -c name /proc/cpuinfo
```

#### Перенаправление ввода/вывода

- Создание нового пустого файла
```
: > filename
```
- Перенаправление stdout и stderr в файл "filename"
```
&>filename
```
- Перенаправляется stderr на stdout
```
2>&1
```

#### Горячие клавиши в шелле
```
Ctrl + a — переход в начало строки (cisco, csh, zsh)
Ctrl + b — переход на 1 символ назад (cisco, csh, zsh)
Ctrl + c — посылает программе SIGINT. Обычно, прерывает текущее задание (csh, zsh)
Ctrl + d — удаляет символ под курсором (аналог delete) (cisco, csh, zsh)
Ctrl + e — переход к концу строки (cisco, csh, zsh)
Ctrl + f — переход на 1 символ вперёд (cisco, csh, zsh)
Ctrl + k — удаляет всё, до конца строки (EOL, а не на экране!) (cisco, csh, zsh)
Ctrl + l — очищает экран. Аналог команды clear. (csh, zsh)
Ctrl + r — поиск по истории. Повторение поиска (листание результатов поиска). То есть инкрементальный поиск. (zsh)
Ctrl + j — прекращает поиск и позволяет отредактировать найденную команду. Если поиск не производился, то аналогично нажатию return. (в zsh выполняет команду)
Ctrl + t — меняет символ под курсором на предыдущий. Или, если хотите, тянет предыдущий символ к концу строки. (cisco, csh, zsh)
Ctrl + u — удаляет все символы слева от курсора до начала строки. (cisco, в csh, zsh удаляет всю строку)
Ctrl + w — удаляет символы слева от курсора до начала слова. (cisco, csh, zsh)
Ctrl + xx — переходит от текущей позиции курса в начало строки и обратно. На циске работает аналогично ctrl + u. (csh)
Ctrl + x @ — показывает возможные дополнения имени хоста (имена берутся из /etc/hosts)
Ctrl + z — suspend'ит текущую задачу (csh, zsh)
Ctrl + x; Ctrl + e — открывает $EDITOR для изменения введённой строки. После сохранения изменений, команда отправляется на исполнение. Если переменная не задана, то открывается системный текстовый редактор (для линукса это, зачастую, nano)

Теперь немного о сочетаниях с альтом.

Alt + < — переход к первой команде в истории команд (zsh)
Alt + > — переход к последней команде в истории
Alt +? — показывает список возможных дополнений команды(аналогично tab-tab) (в csh, zsh аналог which string)
Alt + * — вставляет все возможные дополнений команды в строку команд
Alt + / — пытается дополнить имя файла (аналогично табуляции)
Alt +. — вставляет последний аргумент предыдущей команды (аналог !$, только не надо делать :p, чтобы проверить )
Alt + b — сдвигает курсор влево на 1 слово (cisco, csh, zsh)
Alt + c — делает букву под курсором большой, а остальные, до конца слова, маленькими. (cisco, csh, zsh)
Alt + d — удаляет символы с текущей позиции курсора и до конца слова. (cisco, csh, zsh)
Alt + f — передвигает курсор на одно слово вперёд (cisco, csh, zsh)
Alt + l — делает все буквы с текущей позиции курсора и до конца слова маленькими (cisco, csh, zsh)
Alt + t — меняет местами слова под курсором и предыдущее (zsh)
Alt + u — переводит буквы с текущей позиции курсора и до конца слова в верхний регистр (cisco, csh, zsh)
Alt + back-space — удаляет символы с текущей позиции курсора до начала слова (cisco, csh, zsh)

В следующем абзаце я, для краткости, буду писать «2Т» чтобы обозначить двойное нажатие табуляции.

2T — дополнение команды. Если нажать при пустой строке — выведет список всех доступных команд
(string)2T — выведет список возможных дополнений
(dir)2T — покажет подпапки папки dir
*2T — покажет подпапки исключая скрытые (имена которых начинаются с точки)
~2T — выведет всех пользователей из /etc/passwd. Дополнив имя пользователя можно перейти в его домашний каталог. Например ~oxpa/ — домашний каталог пользователя oxpa
$2T — выводит список дополнений для системных переменных
@2T — дополняет имена хостов содержащимися в /etc/hosts
=2T — листинг текущей директории, аналогичный ls.
```
#### Комментарии

- Быстрый комментарий
```
: << COMMENTBLOCK
echo "Эта строка не будет выведена."
Эта строка комментария не начинается с символа "#".
Это еще одна строка комментария, которая начинается не с символа "#".

&*@!!++=
Эта строка не вызовет ошибки,
поскольку Bash проигнорирует ее.
COMMENTBLOCK
```
#### Отладка сценариев
- Используй команду `echo`, в критических точках сценария, поможет отследить состояние переменных и отобразить ход исполнения
- Команда-фильтр `tee`, которая поможет проверить процессы и потоки данных в критических местах
- Проверить наличие синтаксических ошибок, не запуская сам сценарий
```
bash -n scriptname
# Вставить в сценарий
set -n или set -o noexec
```
- Вывод каждой команды перед её выполнением
```
bash -v scriptname
set -v
set -o verbose
```
- Результат исполнения каждой команды
```
bash -x scriptname
set -x
set -o xtrace
```
-  Получать сообщение об ошибке unbound variable всякий раз, когда будет производиться попытка обращения к необъявленной переменной
```
set -u
set -o nounset
```
- Прерывает работу сценария при появлении первой же ошибки (когда команда возвращает ненулевой код завершения)
```
set -e
```
- Читает команды с устройства stdin
```
set -s
```
- Установки опций в заголовке сценария
```
#!/bin/bash -x
```
- Функция "assert", предназначенная для проверки переменных или условий, в критических точках сценария
- Установка ловушек на сигналы
`trap` - определяет действие при получении сигнала
```
trap 'echo "Control-C disabled."' 2
# Сообщение при нажатии на Control-C.
```
Конструкция `trap '' SIGNAL` (две одиночных кавычки) - запрещает SIGNAL для оставшейся части сценария. Конструкция `trap SIGNAL` - восстанавливает действие сигнала SIGNAL. Эти конструкции могут использоваться для защиты критических участков сценария от нежелательного прерывания.

### Ошибки
- Использование зарезервированных слов и служебных символов в качестве имен переменных.
Имена переменных, начинающиеся с цифр, зарезервированы командной оболочкой.
Если имя переменной начинается с символа подчеркивания: _23skidoo=value1, то это не считается ошибкой.
Если имя переменной состоит из единственного символа подчеркивания, то это ошибка.
- Использование дефиса, и других зарезервированных символов, в именах переменных.
- Использование одинаковых имен для переменных и функций. Это делает сценарий трудным для понимания.
- Использование лишних пробелов. В отличие от других языков программирования, Bash весьма привередлив по отношению к пробелам.
- Ошибочным является предположение о том, что неинициализированные переменные содержат "ноль". Неинициализированные переменные содержат "пустое" (null) значение, а не ноль.
- Часто программисты путают операторы сравнения = и -eq. Запомните, оператор = используется для сравнения строковых переменных, а -eq -- для сравнения целых чисел.

### Неофициальные рекомендации по оформлению сценариев

- Комментируйте свой код. Это сделает ваши сценарии понятнее для других, и более простыми, в обслуживании, для вас.
- Добавляйте заголовочные комментарии в начале сценария и перед функциями.
- Не забывайте начинать ваш сценарий с sha-bang -- #!/bin/bash.
- Заменяйте повторяющиеся значения константами. Это сделает ваш сценарий более простым для понимания и позволит вносить изменения, не опасаясь за его работоспособность.
- В качестве имен переменных и функций выбирайте осмысленные названия.
- Пишите имена констант в верхнем регистре
- Имена кодов ошибок - в верхнем регистре, к тому же, их желательно дополнять префиксом "E_".
- Имена переменных окружения так же желательно записывать символами в верхнем регистре.
- Смешивание символов верхнего и нижнего регистров удобно использовать для имен функций.
- Желательно, чтобы пользовательские переменные не начинались с символа подчеркивания.
- Разделяйте большие сложные сценарии на серию более коротких и простых модулей. Пользуйтесь функциями.
- Не пользуйтесь сложными конструкциями, если их можно заменить простыми.

### Коды завершения, имеющие предопределенный смысл

```
1 разнообразные ошибки (различные ошибки, такие как "деление на ноль" и пр.)
2 согласно документации к Bash - неверное использование встроенных команд (Встречаются довольно редко, обычно код завершения возвращается равным 1)
126 вызываемая команда не может быть выполнена (возникает из-за проблем с правами доступа или когда вызван на исполнение неисполняемый файл)
127 "команда не найдена" (Проблема связана либо с переменной окружения $PATH, либо с неверным написанием имени команды)
128 неверный аргумент команды exit (команда exit может принимать только целочисленные значения, в диапазоне 0 - 255)
128+n фатальная ошибка по сигналу "n" (kill -9 $PPID сценария 	$? вернет 137 (128 + 9))
130 завершение по Control-C (Control-C - это выход по сигналу 2, (130 = 128 + 2, см. выше))
255* (код завершения вне допустимого диапазона)
```

### Специальные переменные
```
$# Количество аргументов командной строки [20], или позиционных параметров
$* Все аргументы в виде одной строки (слова)
$@ То же самое, что и $*, но при этом каждый параметр представлен как отдельная строка (слово), т.е. параметры не подвергаются какой либо интерпретации.
$- Список флагов, переданных сценарию (командой set)
$! PID последнего, запущенного в фоне, процесса
$_ Специальная переменная, содержит последний аргумент предыдущей команды.
$? Код возврата команды, функции или скрипта
$$ PID самого процесса-сценария
```
