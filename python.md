#### Небольшие хитрости в python

0. Задача: Получить список N максимальных или минимальных элементов коллекции.

  ```
  import heapq

  nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
  print(heapq.nlargest(3, nums))   #  Выведет [42, 37, 23]
  print(heapq.nsmallest(3, nums))  #  Выведет [-4, 1, 2]
  ```

0. Задача: Получить максимальное и минимальное значение из списка
  ```
  nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
  import heapq
  heap = list(nums)
  heapq.heapify(heap)
  heap
  # [-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]
  ```

  Самое важная возможность кучи состоит в том, что heap[0] всегда будет
  наименьшим элементом.

  Самый простой способ.

  ```
  print(min(nums))
  print(max(nums))
  ```
  Также
  ```
  print(sorted(nums)[-1:]) # максимальное число
  print(sorted(nums)[:1]) # минимальное число
  ```

0. Задача 3: Создать словарь, который отображает ключи на более чем одно
  значение (так называемый «мультисловарь», multidict).

  ```
  d = {
    'a' : [1, 2, 3],
    'b' : [4, 5]
  }

  e = {
      'a' : {1, 2, 3},
      'b' : {4, 5}
  }
  ```

  Делается это так
  ```
  from collections import defaultdict
  d = defaultdict(list)
  for key, value in pairs:
      d[key].append(value)
  ```
0. Задача: Создать упорядоченный словарь

  ```
  from collections import OrderedDict

  d = OrderedDict()
  d['foo'] = 1
  d['bar'] = 2
  d['spam'] = 3
  d['grok'] = 4
  ```
  OrderedDict внутри себя поддерживает двусвязный список, который
упорядочивает ключи в соответствии с порядком добавления. Когда новый
элемент вставляется впервые, он помещается в конец этого списка.
Последующее связывание значения с существующим ключом не изменяет
порядок.

0. Задача: Проводить различные вычисления (например, поиск минимального
  и максимального значения, сортировку) на словаре с данными.

  Чтобы выполнить вычисления на содержимом словаря, часто бывает полезно
  обратить ключи и значения, используя функцию zip().
  ```
  prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
  }

  prices_sorted = sorted(zip(prices.values(), prices.keys()))
  #[(10.75, 'FB'), (37.2, 'HPQ'), (45.23, 'ACME'), (205.55, 'IBM'), (612.78, 'AAPL')]

  min_price = min(zip(prices.values(), prices.keys()))
  # min_price — (10.75, 'FB')

  max_price = max(zip(prices.values(), prices.keys()))
  # max_price — (612.78, 'AAPL')
  ```
  Когда вы производите эти вычисления, обратите внимание, что zip() создает
итератор, по которому можно пройти только один раз.

0. Задача: Найти общие элементы в двух словарях

  ```
  a = {
      'x' : 1,
      'y' : 2,
      'z' : 3
  }

  b = {
      'w' : 10,
      'x' : 11,
      'y' : 2
  }
  ```

  Чтобы найти общие элементы, просто выполните обычный набор операций с
  использованием методов keys() и items().

  ```
  # Находим  общие  ключи
  a.keys() & b.keys()   # { 'x', 'y' }
  #  Находим  ключи,  которые  есть  в a,  но  которых  нет  в b
  a.keys() - b.keys()   # { 'z' }
  #  Находим  общие  пары (key,value)
  a.items() & b.items()  # { ('y', 2) }
  ```
0. Задача: исключить дублирующиеся значения из последовательности, но
при этом сохранить порядок следования оставшихся элементов.

  ```
  def dedupe(items):
    seen = set()
    for item in items:
        if item not in seen:
            yield item
            seen.add(item)
  ```

  Получим:
  ```
  >>> a = [1, 5, 2, 1, 9, 1, 5, 10]
  >>> list(dedupe(a))
  [1, 5, 2, 9, 10]
  ```
  Если вы просто хотите удалить дубликаты, то часто достаточно будет создать
множество.

  ```
  >>> a
  [1, 5, 2, 1, 9, 1, 5, 10]
  >>> set(a)
  {1, 2, 10, 5, 9}
  ```
  Однако этот поход не сохраняет какой бы то ни было порядок, поэтому
результат будет перемешан.

  ---

    Общее правило таково: написание кода с большим количеством
    неоформленных индексов ведет к проблемам с читабельностью и  поддерживаемостью.

    Встроенная функция slice() создает объект среза, который может быть
  использован везде, где можно бы использовать обычные срезы.

  ---

  Если у вас есть экземпляр slice, сохранённый в переменной s, вы можете
  получить больше информации о нём, если посмотрите на атрибуты s.start,
  s.stop и s.step. Например:
    ```
    >>> a = slice(10, 50, 2)
    >>> a.start
    10
    >>> a.stop
    50
    >>> a.step
    2
    ```
0. Задача: определение наиболее часто встречающихся элементов в последовательности

  ```
  words = [
    'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
    'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
    'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into',
    'my', 'eyes', "you're", 'under'
  ]

  from collections import Counter

  word_counts = Counter(words)
  top_three = word_counts.most_common(3)
  print(top_three)
  #  Выведет [('eyes', 8), ('the', 5), ('look', 4)]
  ```
  На входе объектам класса Counter можно скормить любую
  последовательность хэшируемых элементов. В основе Counter лежит
  словарь, который отображает элементы на количество вхождений.
  ```
  >>> word_counts['not']
  1
  >>> word_counts['eyes']
  8
  ```
0. Создать список, при этом есть два условия

```
return [int(sqrt(a)) if sqrt(a) % 1 == 0 else a ** 2 for a in arr]
```
Возвратит список корней числа, если есть корни, если нет, вернет квадрат

0. Заменить if/else и вернуть True или False 

```
def is_lucky(t):
    try: return len(t)==6 and sum(map(int,t[:3]))==sum(map(int,t[-3:]))
    except: return False
```

0. Преобразовать список чецлых чисел в одно число
```
map(int, str(n))
```
[1,3,2,5,3] -> 13253

0. Имеется переменная d, в зависиммости от d применить несколько условий.

Можно решить задачу так:
```
def rental_car_cost(d):
    # your code
    if (d>=3 and d<7):
        return d*40 - 20
    elif (d>=7):
        return d*40 -50
    else:
        return d*40
```
А лучше так:
```
def rental_car_cost(d):
  return d * 40 - (d > 2) * 20 - (d > 6) * 30
```

0. Удалить символ из строки

```
x = 'abc'.split
x['b'] -> ['a', 'c']
```

0.  Есть строка цифр 123456789 (пусть я и правда не очень интересуюсь нулем), между которыми можно в любых местах поставить 4 арифметических операции (+, -, *, /) или не ставить ничего (то есть ставить пустую строку, тогда образуются двух- и более -значные числа) так, чтобы общее выражение давало в результате 100

```
#!/usr/bin/env python
#-*- coding:utf-8 -*-

from __future__ import division
from itertools import product

sum_num = 100
count =  0

digits = '123456789'
signs = '', '+', '-', '*', '/'
atoms = [map(lambda x: d + x, signs) for d in digits[:8]]

for indexes in product(range(5), repeat=8):
    expr = "".join( [ atoms[i][indexes[i]] for i in range(8) ] )
    expr += '9'
    if eval(expr) == sum_num:
        print('{0} = {1}'.format(expr, sum_num))
        count += 1
 
print 'So, {0} expressions for {1}'.format(count, sum_num)
```
