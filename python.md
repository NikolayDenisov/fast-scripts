#### Небольшие хитрости в python

0. Задача: Получить список N максимальных или минимальных элементов коллекции.

  ```
  import heapq

  nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
  print(heapq.nlargest(3, nums))   #  Выведет [42, 37, 23]
  print(heapq.nsmallest(3, nums))  #  Выведет [-4, 1, 2]
  ```

0. Задача: Получить максимальное и минимальное значение из списка
  ```
  nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
  import heapq
  heap = list(nums)
  heapq.heapify(heap)
  heap
  # [-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]
  ```

  Самое важная возможность кучи состоит в том, что heap[0] всегда будет
  наименьшим элементом.

  Самый простой способ.

  ```
  print(min(nums))
  print(max(nums))
  ```
  Также
  ```
  print(sorted(nums)[-1:]) # максимальное число
  print(sorted(nums)[:1]) # минимальное число
  ```

0. Задача 3: Создать словарь, который отображает ключи на более чем одно
  значение (так называемый «мультисловарь», multidict).

  ```
  d = {
    'a' : [1, 2, 3],
    'b' : [4, 5]
  }

  e = {
      'a' : {1, 2, 3},
      'b' : {4, 5}
  }
  ```

  Делается это так
  ```
  from collections import defaultdict
  d = defaultdict(list)
  for key, value in pairs:
      d[key].append(value)
  ```
0. Задача: Создать упорядоченный словарь

  ```
  from collections import OrderedDict

  d = OrderedDict()
  d['foo'] = 1
  d['bar'] = 2
  d['spam'] = 3
  d['grok'] = 4
  ```
  OrderedDict внутри себя поддерживает двусвязный список, который
упорядочивает ключи в соответствии с порядком добавления. Когда новый
элемент вставляется впервые, он помещается в конец этого списка.
Последующее связывание значения с существующим ключом не изменяет
порядок.

0. Задача: Проводить различные вычисления (например, поиск минимального
  и максимального значения, сортировку) на словаре с данными.

  Чтобы выполнить вычисления на содержимом словаря, часто бывает полезно
  обратить ключи и значения, используя функцию zip().
  ```
  prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
  }

  prices_sorted = sorted(zip(prices.values(), prices.keys()))
  #[(10.75, 'FB'), (37.2, 'HPQ'), (45.23, 'ACME'), (205.55, 'IBM'), (612.78, 'AAPL')]

  min_price = min(zip(prices.values(), prices.keys()))
  # min_price — (10.75, 'FB')

  max_price = max(zip(prices.values(), prices.keys()))
  # max_price — (612.78, 'AAPL')
  ```
  Когда вы производите эти вычисления, обратите внимание, что zip() создает
итератор, по которому можно пройти только один раз.

0. Задача: Найти общие элементы в двух словарях

  ```
  a = {
      'x' : 1,
      'y' : 2,
      'z' : 3
  }

  b = {
      'w' : 10,
      'x' : 11,
      'y' : 2
  }
  ```

  Чтобы найти общие элементы, просто выполните обычный набор операций с
  использованием методов keys() и items().

  ```
  # Находим  общие  ключи 
  a.keys() & b.keys()   # { 'x', 'y' }
  #  Находим  ключи,  которые  есть  в a,  но  которых  нет  в b
  a.keys() - b.keys()   # { 'z' }
  #  Находим  общие  пары (key,value)
  a.items() & b.items()  # { ('y', 2) }
  ```
